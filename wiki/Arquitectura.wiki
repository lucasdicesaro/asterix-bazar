#summary (Información Técnica y Funcional) Detalles
#labels Arquitectura,Threads

== Introducción ==

Esta sección explica cómo esta pensada la aplicación desde el punto de vista de la arquitectura. En el mismo, se tuvieron que desarrollar diferentes técnicas para afrontar diversos problemas que se presentaron durante la etapa de diseño y desarrollo. Tales como, la transaccionalidad y la identificación de mensajes de manera unívoca mediante timestamp en sistemas distribuidos.

== Detalles ==

=== Topología ===

Los nodos se interconectan de una manera particular.
Se sabe, según la consigna, que cada nodo tiene dos vecinos. Por una decisión de diseño, se implemento la idea armar por separado las conexiones de los vecinos (conexiones de salida), de las conexiones que acepto de otros vecinos (conexiones de entrada). De esta manera, se logra organizar los mensajes y se evita la colisión de mensajes.


=== Threading ===

Este trabajo es una aplicación basada en multi-threading, donde cada thread es responsable de una tarea. Los threads son los siguientes:
  * Un thread *Listener*, que es el responsable de aceptar nuevas conexiones, darlas de baja, y recibir paquetes de provenientes de la red.
  * Un thread *Router*, que es el responsable de perdir conexiones a sus dos vecinos asignados (mediante el archivo de configuración) y de enviar los paquetes a la red.
  * Un thread *Keyboard*, se responsabiliza de tomar la entrada del usuario. El detalle de este thread se explica en otra sección.
  * Un thread *Logic*, que es el responsable de todo el negocio de la aplicación. Es el úcleo de la aplición. El mismo interpreta los mensajes provenientes del _Listener_, toma decisiones y arma nuevos mensajes para enviarle al _Router_. 


=== Paso de mensajes ===

Para el paso de mensajes entre los nodos, se utiliza el standard XML. 
Abajo se decribe el protocolo de mensajes utilizado entre los nodos.

|| *Code* || *Vendedor* || *Product* || *Cantidad* || *Hopcount* || *Timestamp* ||
|| LOOKUP || - || sal/pescado/verdura || 0..n || 0..n || segundos|microsegundos ||
|| REPLY || nombre_nodo || sal/pescado/verdura || 0..n || - || segundos|microsegundos ||
|| BUY || nombre_nodo || sal/pescado/verdura || 0..n || - || segundos|microsegundos ||
|| BUY_OK || nombre_nodo || sal/pescado/verdura || 0..n || - || segundos|microsegundos ||
|| BUY_ERR || nombre_nodo || sal/pescado/verdura || 0..n || - || segundos|microsegundos ||


=== Flooding ===

El mensaje de REPLY vuelve solo por el camino por donde paso el LOOKUP. 
Para implementar esto, en el mensaje viaja los nombres de los nodos por donde paso el LOOKUP. Cada nodo al transpasar un LOOKUP (ademas de decrementar su HOPCOUNT), se agrega en la lista de nodos que indica por donde ya paso el mensaje.

Por el contratrio, cuando se incia un mensaje de REPLY, al atravezar el camino inverso, cada nodo va quitando su nombre de la lista, hasta llegar a tener único nodo que coincide con el nodo que originó el mensaje.

=== Timestamp ===

Un Comprador publica su necesidad de compra mediante un LOOKUP. Cuando un Vendedor detecta, que sus productos son requeridos por algun comerciante, el mismo lanza un REPLY por el mismo camino por donde vino el LOOKUP.

==== Múltiples respuestas ===== 
El problema de las Múltiples respuestas aparece cuando hay mas de un Vendedor que responde a un pedido, pues el Comprador va a recibir más de un REPLY. Seria un error iniciar la negociación con ambos Vendedores. 

==== Respuesta tardía ===== 
Otro problema aparece cuando llega una respuesta tardia. Ya habiendo hecho la negociación, al Comprador le puede llegar un REPLY e iniciar una nueva negociación


Para solucionar estos problemas de sistemas distribuidos se planteó un esquema de *timestamp*, donde cada comprador tiene un mapa de los mensajes de pedido de compra que él mismo inicia. 

Dicho mapa se conforma de la siguiente manera:
|| Clave || Valor ||
|| Timestamp || Estado del Mensaje ||

Timestamp: Conformado por los segundos, mas los microsegundos del sistema.
Estado del mensaje: LOOKUP_ENVIADO/REPLY_RECIBIDO
Estos estados indican que el pedido fue iniciado y el mismo fue respondido, respectivamente.

Durante el desarrollo se detectó que la aplicación, al ser un sistema distribuido, el timestamp podia coincidir con el de otro nodo. De esta manera, podria darse el caso en que estoy pasando un mensaje REPLY que no me corresponde, pero por tener un timestamp que genere yo, lo doy como respondido en mi mapa, generando un estado de inconsistencia en el nodo.

Gracias a lo que se explica en Flooding, este problema no podria darse ya que el mensaje de REPLY vuelve le llega a un unico nodo. 
En caso de que no existiera esta restricción, una buena solución que se aplica a sistemas distribuidos es la de concatenar el timestamp con el nombre del nodo.

=== Transaccionalidad ===
En el momento de la negociación, interactúan dos nodos. Dichos nodos, deben modificar su stock. Para eso hay que aplicar un mecanismo de transacciones para evitar inconsistencias por error en la comunicacion. Para eso, se utiliza un flag global ('en operacion') que indica si un usuario esta en negociación o no. Una vez finalizada la negociación se setean estos flags a sus estados originales. 

Esto también logra un efecto de aislamiento hacia el resto de la red, rechazando cualquier tipo de mensaje proveniente de la red, excepto del nodo con el cual se estableció la negociación. Esta técnica es de gran ayuda para mantener la consistencia del stock de cada nodo.